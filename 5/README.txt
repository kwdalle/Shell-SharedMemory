The code for the shell is all in the file shell.c. This file runs an infinite loop which will only end once the user issues the command “exit”. Throughout the program certain flags are looked for in the input to the shell. These different flags tell the shell to execute different types of commands (like pipe, redirect and history). The command is tokenized into the args array which is then used by the majority of the program for executing the commands. After it is tokenized is when we check the flags to see if it needs to execute special commands in the shell. For example, this is where I check for the different types of history commands and retokenize the stored commands. Then comes redirect, here I execute the command after changing the stdout to the specified file. At the end of that I switch back to the normal stdout. Pipe is done similar except the input and output is switched to the pipe. Here I have the child execute the first command, while the parent is blocked while waiting for the child to input data to the pipe. The input and output are the reset back to the normal values. Finally we come to the part where normal commands are executed. First I fork, then the child executes the command. In the parent I check whether it is a background command or not. If it is then the parent finishes and the shell reappears, otherwise the parent waits for the child to be complete. There were some complications in this program. For instance the history repeat commands are not able to handle piped commands for some reason. I tried to figure this out for a few days and was unable to do so. Also, there is a presentation error after a background process finishes or is killed, the prompt will not appear in the correct spot. Most of the problems in this program will surface within the history command, however all commands in the assignment document will work.
